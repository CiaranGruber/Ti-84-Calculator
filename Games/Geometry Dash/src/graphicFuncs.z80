drawSprite:
	; INPUT : 
	;	IX : sprite data
	;	HL : Position (ADDR)
	;	DE : width of the buffer/screen
	ld bc,(ix)
	inc ix
	inc ix
drawSpriteY:
	push bc
	push de
	ld b,c
drawSpriteX:
	ld a,(ix)
	cp BGCl_menu
	jr z,noDraw
	ld (hl),a
noDraw:
	inc hl
	inc ix
	djnz drawSpriteX
	pop de
	add hl,de
	inc.s bc
	ld b,0
	dec c
	or a
	sbc hl,bc
	pop bc
	djnz drawSpriteY
	ret

drawSpriteMirror:
	; INPUT : 
	;	IX : sprite data
	;	HL : Position (ADDR)
	ld bc,(ix)
	inc ix
	ld de,0
	ld e,c
	add ix,de
drawSpriteMirrorY:
	push bc
	ld b,c
drawSpriteMirrorX:
	ld a,(ix)
	cp BGCl_menu
	jr z,MIR_noDraw
	ld (hl),a
MIR_noDraw:
	inc hl
	dec ix
	djnz drawSpriteMirrorX
	ld de,320
	add hl,de
	ld d,0
	ld e,c
	or a
	sbc hl,de
	sla e
	add ix,de
	pop bc
	djnz drawSpriteMirrorY
	ret


putGDFont:
	; INPUT :
	;	HL : pos
	;	IX : string
	ld b,(ix)
	inc ix
putGDFont_loop:
	ld a,(ix)
	cp ' '
	jr nz,notSpace
	ld de,10
	add hl,de
	inc ix
	djnz putGDFont_loop
	ret
notSpace:
	push bc
	dec a
	push hl
	ld e,a
	or a
	rla
	add a,e
	ld hl,_GDfont_tiles
	ld de,0
	ld e,a
	add hl,de
	ld de,(hl)
	pop hl

	ld b,28
drawLetterY:
	push bc
	ld b,28
drawLetterX:
	ld a,(de)
	cp BGCl_menu
	jr z,emptyPxl
	ld (hl),a
emptyPxl:
	inc hl
	inc de
	djnz drawLetterX
	ld bc,250-28
	add hl,bc
	pop bc
	djnz drawLetterY
	ld bc,-(28*250)+25
	add hl,bc
	inc ix
	pop bc
	djnz putGDFont_loop
	ret


centerText:
	; INPUT :
	;	HL : beginning
	;	DE : Space (pxl)
	;	IX : string
	; OUTPUT :
	;	HL : new display location
	push hl
	ld hl,0
	ld b,(ix)
	inc ix
	push de
calculatingSpace:
	ld a,(ix)
	inc ix
	cp ' '
	jr nz,CEN_letter
	ld de,10
	add hl,de
	djnz calculatingSpace
	jr end_calculatingSpace
CEN_letter:
	ld de,25
	add hl,de
	djnz calculatingSpace
end_calculatingSpace:
	pop de
	ex de,hl
	or a
	sbc hl,de
	srl l
	pop de
	add hl,de
	ret


extractRLE:
	; INPUT :
	;	BC : number of "colors"
	;	HL : FROM
	;	DE : TO
	push bc
	ld a,(hl)
	ld b,a
	inc hl
	ld a,(hl)
copyXpxls:
	ld (de),a
	inc de
	djnz copyXpxls
	inc hl
	pop bc
	dec bc
	xor a
	cp c
	jr nz,extractRLE
	cp b
	jr nz,extractRLE
	ret


Fcircle:
	push iy
	push hl
	push de
	push bc
	push af
	ld  (FCircleCenterPos_SMC),hl
	ld  bc,0
	ld  c,a
	sbc     hl,bc
	ld  (FCircleLdirpos_SMC),hl
	ex  de,hl                               ; de = x coord - radius
	ld  hl,colorCircle               ; hl = color of circle
	push    de
	ldi
	pop hl
	ret     po
	rlc     c
	inc c
	ldir
	ld  (FCircleLddrpos_SMC),hl
	ld  b,a
	inc a
	ld  d,a
	ld  e,a
	mlt     de
	ld  iy,0
	add iy,de
	ld  c,a
Fory:
	lea hl,iy+0                     ; kind of For(y,R,1,-1
	ld  a,c
	ld  d,b
	ld  e,b
	mlt     de                          ; de = y²
	sbc     hl,de
	ex  de,hl                       ; de = (R²-y²)

Forx:
	ld  h,a                         ; kind of For(x,R,y,-1
	ld  l,a
	mlt     hl                          ; hl = x²
	sbc     hl,de                       ; x² < (R² - y²) ?
	dec a
	jr  nc,Forx                     ; no?   then loop
	push    bc                          ; yes?  here we go!
FCircleCenterPos_SMC =$+1
	ld  hl,0                        ; hl = 'on-screen' center pos
	ld  c,lcdWidth/2
	mlt     bc
	push    bc                          ; bc = 160*y
	add hl,bc
	add hl,bc
	ld  b,0
	ld  c,a                         ; bc = x
	add hl,bc
	ex  de,hl                       ; de = 'on-screen' horizontal drawing beginning address
FCircleLddrpos_SMC =$+1
	ld  hl,0                        ; hl = pointer to color data
	ld  b,0
	inc a
	rlca
	ld  c,a                         ; bc = drawing length
	lddr                                ; trace 1st horizontal line (bottom)
	pop hl                          ; now, calculate mirrored position...
	add hl,hl
	add hl,hl                       ; hl = 160*y*4
	inc de
	ex  de,hl
	sbc     hl,de
	ex  de,hl                       ; de = 'on-screen' horizontal drawing beginning address
	; added
	ld hl,vRam
	or a
	sbc hl,de
	jr nc,dontDisp
	; *****
FCircleLdirpos_SMC =$+1
	ld  hl,0                        ; hl = pointer to color data
	ld  c,a                         ; bc = drawing length
	ldir                                ; trace 2nd horizontal line (top)
dontDisp:
	pop bc
	djnz    Fory
	pop af
	pop bc
	pop de
	pop hl
	pop iy
	ret
colorCircle:
	.db 4