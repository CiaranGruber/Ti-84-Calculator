.nolist
	#define db .db
	#define dw .dw
	#define dl .dl
	#include "GeometryDash_Data\ti84pce.inc"
	#macro bcall(x)
		call x
	#endmacro
	; constants
	#DEFINE TIL_sizeY 	21
	#DEFINE TIL_sizeX 	21
	#DEFINE MAP_sizeY 	10
	#DEFINE WIN_sizeY 	10
	#DEFINE WIN_sizeX 	16
	#DEFINE SPR_sizeX 	30
	#DEFINE SPR_sizeY 	30
	#DEFINE SPHP_sizeX 	22
	#DEFINE SPHP_sizeY 	22
	#DEFINE SPR_posX	80
	#DEFINE	SCROLL_spd	08
	#DEFINE BGCl		$7F
	#DEFINE BGCl_menu	$07
	#DEFINE TAIL_nb		08
	#DEFINE TAIL_fstClr	$FC
	#DEFINE beg_sprite	5*320+5
	#DEFINE nbrLevels	2
	#DEFINE tilesExtracted		pixelshadow2-6000
	#DEFINE tilesExtractedMenu	plotSScreen
	#DEFINE sizeGDFont	28*28*26
	; saferam
	;#DEFINE TRS_paletteSRC	(pixelshadow2-3900)
	
	#DEFINE fstBlock 		pixelshadow		; adresse du block en haut à gauche de la fenêtre (dans le cas où le scroll serait à son max)
	#DEFINE dispBlkFrmX		pixelshadow+3	; offset depuis le début du niveau
	#DEFINE	Vcharacter_posY	pixelshadow+6	; position du sprite sur l'écran
	#DEFINE	prev_posY		pixelshadow+9	; position du sprite sur l'écran sur la précédente frame (sert à effacer le sprite)
	#DEFINE	jmp_speed		pixelshadow+12	; vitesse du saut
	#DEFINE spr_state		pixelshadow+15	; sprite we are displaying [0-9]
	#DEFINE prev_sprState	pixelshadow+18	; previous sprite we were displaying [0-9]
	#DEFINE currentTailEl	pixelshadow+21	; sert pour les étincelles qui suivent le sprite
	#DEFINE MAP_sizeX		pixelshadow+24	; taille X de la map qui est en train d'être jouée
	#DEFINE dispBlkFrmY		pixelshadow+27	; 
	#DEFINE prev_speed		pixelshadow+30	; ancienne vitesse du saut
	#DEFINE prv_spdDiv320	pixelshadow+33	; ancienne vitesse du saut/320
	#DEFINE bytesToSkip		pixelshadow+36	; offset qui pointe vers le block en haut à gauchde de la fenetre (pour le scroll en place)
	#DEFINE maxBytesToSkip	pixelshadow+39	; nombre de block qu'on peut sauter au maximum (pour le vertical scrolling, définit la valeur max de bytestosip)
	#DEFINE currentSprBuf	pixelshadow+42	; buffer en cours sur cette frame (voir behindSprite1/20)
	#DEFINE addrGravity		pixelshadow+45	; adresse qui pointe vers l'adresse du prochain changement de gravité
	#DEFINE nbChngGrvtyRmng	pixelshadow+48	; combien il reste de changement de gravité sur ce niveau
	#DEFINE addrSpaceship	pixelshadow+51	; adresse qui pointe vers l'adresse du prochain changement de véhicule
	#DEFINE nbChngSphpRmng	pixelshadow+54	; combien il reste de changement de véhicule sur ce niveau
	#DEFINE beginningMap	pixelshadow+57	; adresse du point en haut à gauche de la map
	#DEFINE spriteSize		pixelshadow+60	; taille de l'actuel sprite (en fonction du véhicule, 30 ou 22)
	;#DEFINE TRS_paletteDST	pixelshadow+66
	;#DEFINE TRS_counter		pixelshadow+66
	#DEFINE mn				pixelshadow+97 ; used as scrapMem
	#DEFINE behindSprite1	pixelshadow+100 ; 900 bytes (30*30)
	#DEFINE behindSprite2	pixelshadow+1000 ; 900 bytes (30*30)
	#DEFINE nmbOfLevels		cursorImage		; used in the main menu
	#DEFINE namesBuf		cursorImage+3	; used in the main menu
	; FLAGS
	;	asm_flag1
	#DEFINE	FLG_jumping		0 ; flag (sprite is jumping or spaceship is flying)
	#DEFINE FLG_jmpAgain	1 ; flag (if user pressed the 2nd key while jumping)
	#DEFINE FLG_rvrsGravity	2 ; flag (1=gravity reversed)
	#DEFINE FLG_spaceshipOn	3 ; flag (1=spaceship)
	#DEFINE FLG_topReached	4 ; flag (used to synchronize the buffers)
	#DEFINE FLG_botReached	5 ; flag (used to synchronize the buffers)
	#DEFINE FLG_chgOfDir	6 ; flag (when user changes the direction of the spaceship)
	#DEFINE FLG_alrdyErased	7 ; flag ()
	;	asm_flag2
	#DEFINE FLG_pauseLeft	0 ; flag ()
	;#DEFINE FLG_colorTRS	1 ; flag ()
	#DEFINE FLG_noLevel		2 ; flag (if there's no level on the calc)
	#DEFINE FLG_jmpUsed		3 ; flag (prevent sprite from jumping on a yellow tile if user did not re-pressed 2nde)
	;COMPATIBILITÉ AVEC ANCIENNE VERSION (sans vaisseau spatial)
	#DEFINE FLG_sphpAvlble	4
.list
	.org userMem-2
	.db tExtTok,tAsm84CeCmp

	
start:
	; AppVars stuffs
	ld hl,AppVarGraphics
	call _mov9ToOp1
	call _chkFindSym
	jr nc,AppVarGraphicsFound
	call _clrlcdfull
	call _homeUp
	ld hl,ERR_needGrphc
	call _PutS
	call _getkey
	ret
AppVarGraphicsFound:
	call _chkInRam
	call z,_ARC_UNARC
	ld hl,AppVarMenu
	call _mov9ToOp1
	call _chkFindSym
	jr nc,AppVarMenuFound
	call _clrlcdfull
	call _homeUp
	ld hl,ERR_needMenu
	call _PutS
	call _getkey
	ret
AppVarMenuFound:
	call _chkInRam
	call z,_ARC_UNARC

	ld hl,AppvarStoreScore
	call _mov9ToOp1
	call _chkFindSym
	jr nc,appvarExists
	ld hl,6 ; in this appvar : high score of the levels
	call _createAppvar
	inc de
	inc de
	ex de,hl
	ld de,0
	ld (hl),de
	inc hl
	inc hl
	inc hl
	ld (hl),de
	push hl
	call _op4toop1
	pop de
appvarExists:
	call _chkInRam
	call z,_ARC_UNARC

	call _RunIndicOff
	ld a,(mpLcdImsc)
	or a,4 ; bitLcdLnBuim
	ld (mpLcdImsc),a
	ld a,lcdBpp8
	ld (mpLcdCtrl),a

	ld hl,namesBuf
	ld (current_level),hl

menuGame:
	DI
	; looking for level appvars in VAT
	ld hl,(progPtr)
	ld ix,namesBuf ; address[3] addrAfterName[3] → 6 bytes
	ld iy,0
loopNextAppV:
	ex de,hl
	ld hl,(OPBase)
	or a
	sbc hl,de
	jp nc,lastElement
	ex de,hl

	ld a,(hl)
	ld de,-6
	add hl,de
	cp AppVarObj
	jr z,AppVarFound
	ld a,(hl)
	inc a
	ld de,0
	ld e,a
	or a
	sbc hl,de
	jr loopNextAppV
AppVarFound:
	dec hl
	ld a,(hl)
	inc hl
	cp 'L'
	jr nz,notForGD
	push hl
	inc hl
	ld a,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	ld (scrapMem),de
	ld (scrapMem+2),a
	ld de,(scrapMem)
	cp $D0
	jr nc,appVarInRAM
	ex de,hl
	ld de,9
	add hl,de
	ld a,(hl)
	inc a
	ld e,a
	add hl,de
	ex de,hl
appVarInRAM:
	inc de
	inc de
	; looking for "stringToFind"
	ld hl,stringToFind
	ld b,(hl)
	inc hl
stringToFind_loop:
	ld a,(de)
	cp (hl)
	jr nz,notForGD-1
	inc hl
	inc de
	djnz stringToFind_loop
	ex de,hl
	ld (ix),hl
	inc ix
	inc ix
	inc ix
	ld bc,0
	ld c,(hl)
	add hl,bc
	inc hl
	ld c,(hl)
	add hl,bc
	inc hl
	ld (ix),hl
	inc ix
	inc ix
	inc ix
	inc iy
	pop hl
notForGD:
	ld a,(hl)
	inc a
	ld de,0
	ld e,a
	or a
	sbc hl,de
	jp loopNextAppV
lastElement:
	ld (nmbOfLevels),iy
	ld iy,flags
	ld a,(nmbOfLevels)
	res FLG_noLevel, (iy+asm_flag2)
	or a
	jr nz,levelFound
	set FLG_noLevel, (iy+asm_flag2)
levelFound:

	; extracting data
	ld hl,AppVarMenu
	call _mov9ToOp1
	call _chkFindSym
	ld hl,18
	add hl,de
	ld bc,(hl)
	inc hl
	inc hl
	inc hl
	ld de,tilesExtractedMenu
	call extractRLE

	; clear screen
	ld hl,vRam
	ld (hl),BGCl_menu
	ld de,vRam+1
	ld bc,320*240*2
	ldir
	ld de,mpLcdPalette
	ld hl,_menu_pal
	ld bc,512
	ldir

	; draw floor
	ld hl,vRam+(320*TIL_sizeY*MAP_sizeY)
	ld (hl),0
	ld de,vRam+(320*TIL_sizeY*MAP_sizeY)+1
	ld bc,320*1
	ldir
	ld (hl),06
	ld bc,320*240-((320*TIL_sizeY*MAP_sizeY)+(320*1))
	ldir
	ld hl,vRam+(320*TIL_sizeY*MAP_sizeY)+(320*240)
	ld (hl),0
	ld de,vRam+(320*TIL_sizeY*MAP_sizeY)+(320*240)+1
	ld bc,320*1
	ldir
	ld (hl),06
	ld bc,320*240-((320*TIL_sizeY*MAP_sizeY)+(320*1))
	ldir

	ld hl,vRam+(320*100)+2
	ld ix,tilesExtractedMenu+sizeGDFont ; _menu_tile_0
	ld de,320
	call drawSprite

	ld hl,vRam+(320*100)+290
	ld ix,tilesExtractedMenu+sizeGDFont ; _menu_tile_0
	ld de,320
	call drawSpriteMirror

	ld hl,vRam+(320*199)
	ld ix,tilesExtractedMenu+sizeGDFont+5050
	ld de,320
	call drawSprite

	ld hl,vRam+(320*199)+278
	ld ix,tilesExtractedMenu+sizeGDFont+5050
	ld de,320
	call drawSpriteMirror

	ld hl,vRam+60
	ld ix,tilesExtractedMenu+sizeGDFont+5050+1724
	ld de,320
	call drawSprite

	bit FLG_noLevel, (iy+asm_flag2)
	jp nz,LOOP_noLevel

	ld a,9
	ld (colorCircle),a
	ld a,13
	ld hl,vRam+(320*170)+77
	ld b,22
	ld de,8
drawBarBord:
	call Fcircle
	add hl,de
	djnz drawBarBord

menuGameNoClr:
	ld a,140 ; 098C6h
	ld (colorCircle),a
	ld a,10
	ld hl,vRam+(320*170)+81
	ld b,21
	ld de,8
drawBar:
	call Fcircle
	add hl,de
	djnz drawBar

	; draw main rectangle
	ld hl,pixelshadow
	ld (hl),8
	ld de,pixelshadow+1
	ld bc,80*250
	ldir

	ld ix,(current_level)
	pea ix+3
	ld ix,(ix)
	ld hl,pixelshadow+(250*27)+40
	ld de,25*8
	push ix
	call centerText
	ld a,(ix)
	pop ix
	or a
	jr z,oneName
	ld de,-250*15
	add hl,de
	call putGDFont
	ld hl,pixelshadow+(250*45)+40
	ld de,25*8
	push ix
	call centerText
	pop ix
oneName:
	call putGDFont
	
	pop hl
	ld hl,(hl)
	ld a,(hl)
	ld de,30*30+2
	call _Mult16By8
	ld ix,tilesExtractedMenu+sizeGDFont+1442
	ex de,hl
	add ix,de
	ld hl,pixelshadow+(250*23)+5
	ld de,250
	call drawSprite

	ld de,pixelshadow
	ld hl,vRam+(55*320)+35
	ld b,80
ANIM_dispRectInfoY:
	push bc
	ld b,250
ANIM_dispRectInfoX:
	ld a,(de)
	ld (hl),a
	ld a,10
DSP_pause:
	ld ix,(0)
	dec a
	jr nz,DSP_pause
	inc hl
	inc de
	djnz ANIM_dispRectInfoX
	ld bc,320-250
	add hl,bc
	pop bc
	djnz ANIM_dispRectInfoY

	ld hl,(current_level)
	inc hl
	inc hl
	inc hl
	ld hl,(hl)
	inc hl
	ld de,(hl)
	push de
	push hl
	call findHighScoreInAppVar
	ld hl,(ix)
	pop ix
	pop de
	jp nz,neverPlayed

	push de
	call _setXXXXop2
	ld a,21
	call _setxxop1
	call _FPmult
	pop de
	ld hl,$010000
	sbc hl,de
	jr nc,oldVerWhithoutSpeed
	inc ix
oldVerWhithoutSpeed:
	inc ix
	inc ix
	inc ix
	ld hl,(ix)
	call _setHLUTo0
	call _setXXXXop2
	call _FPDiv
	call _convop1
	ld b,e
	xor a
	cp b
	jr z,neverPlayed

	ld a,$2E
	ld (colorCircle),a
	ld hl,vRam+(320*170)+81
	ld de,8
drawBarFill:
	ld a,10
	call Fcircle
	exx
	ld hl,$F50000
	ld (hl),2
	xor a
FILL_scanWait:
	cp (hl)
	jr nz,FILL_scanWait
	ld a,(kbdG7)
	bit kbitLeft, a
	jp nz,prev_level
	bit kbitRight, a
	jp nz,next_level
	; quit
	ld a,(kbdG1)
	bit kbitMode, a
	jp nz,quit
	bit 7, a
	jp nz,quit
	ld a,(kbdG6)
	bit kbitClear, a
	jp nz,quit
	; play
	bit kbitEnter, a
	jr nz,fillingPlayLevel
	ld a,2
	call _DelayTenTimesAms
	exx
	add hl,de
	djnz drawBarFill
neverPlayed:


menuGameLoop:
	ld hl,$F50000
	ld (hl),2
	xor a
MENU_scanWait:
	cp (hl)
	jr nz,MENU_scanWait
	ld a,(kbdG7)
	bit kbitLeft, a
	jp nz,prev_level
	bit kbitRight, a
	jp nz,next_level
	; quit
	ld a,(kbdG1)
	bit kbitMode, a
	jp nz,quit
	bit 7, a
	jp nz,quit
	ld a,(kbdG6)
	bit kbitClear, a
	jp nz,quit
	; play
	bit kbitEnter, a
	jr z,menuGameLoop
fillingPlayLevel:
	call playLevel
	xor a
	ld (mpLcdRange+11),a
	ld hl,$EF7802
	ld (mpLcdRange+8),hl
	ld hl,vRam
	ld (mpLcdBase),hl
	jp menuGame


addHighScore:
	push af
	ld hl,AppvarStoreScore
	call _mov9ToOp1
	call _pushrealo1
	call _ARC_UNARC
	ld hl,(current_level)
	inc hl
	inc hl
	inc hl
	ld hl,(hl)
	inc hl
	ld de,(hl)
	push hl
	call findHighScoreInAppVar
	call nz,newHighScore
	pop hl
	pop af
	or a
	jr nz,HS_endOfLevel
	push hl
	ld bc,(ix)
	ld hl,(fstBlock)
	ld de,(bytesToSkip)
	or a
	sbc hl,de
	pop de
	inc de
	inc de
	inc de
	inc de
	inc de
	sbc hl,de
	push hl
	sbc hl,bc
	pop hl
	jr c,endNewHighScore
	ld (ix),hl
	; affichage HIGH SCORE
	ld hl,(mpLcdBase)
	ld de,(90*320)+((320-194)/2)
	add hl,de
	ld de,320
	ld ix,tilesExtracted+(21*21*56)+(900*11)+(22*22*13)
	call drawSprite
endNewHighScore:
	call _poprealo1
	call _ARC_UNARC
	ret

HS_endOfLevel:
	ld hl,(MAP_sizeX)
	ld (ix),hl
	jr endNewHighScore

newHighScore:
	ld bc,-6
	add ix,bc
	ld (ix),de
	inc ix
	inc ix
	inc ix
	push ix
	lea de,ix+3
	ld hl,6
	call _insertMem
	ex de,hl
	ld de,0
	ld (hl),de
	inc hl
	inc hl
	inc hl
	ld (hl),de
	call _CpyTo1FPST
	call _chkFindSym
	ex de,hl
	ld de,(hl)
	ld ix,6
	add ix,de
	ld (hl),ix
	pop ix
	ret

prev_level:
	ld hl,(current_level)
	ld de,-6
	add hl,de
	ex de,hl
	ld hl,namesBuf
	or a
	sbc hl,de
	jr c,PREV_noProblem
	jr z,PREV_noProblem
	ld bc,(nmbOfLevels)
	dec c
	ld b,6
	mlt bc
	ld hl,namesBuf
	add hl,bc
	ex de,hl
PREV_noProblem:
	ld (current_level),de
	jp menuGameNoClr

next_level:
	ld hl,(current_level)
	ld de,6
	add hl,de
	ex de,hl
	ld bc,(nmbOfLevels)
	ld b,6
	mlt bc
	ld hl,namesBuf
	add hl,bc
	sbc hl,de
	jr z,NEXT_lastLevel
	jr nc,NEXT_noProblem
NEXT_lastLevel:
	ld de,namesBuf
NEXT_noProblem:
	ld (current_level),de
	jp menuGameNoClr

	pop ix ; reset stack
	pop ix
	pop ix
speedQuit:
	pop ix
	xor a
	ld (mpLcdRange+11),a
	ld hl,$EF7802
	ld (mpLcdRange+8),hl
	ld hl,vRam
	ld (mpLcdBase),hl

quit:
	; removing the timer
	ld a,(mpTmrCtrl)
	and %11010111
	ld (mpTmrCtrl),a
	; ---------------------------------
	EI
	call _clrlcdall
	ld a,lcdBpp16
	ld (mpLcdCtrl),a
	ld hl,vRam
	ld (mpLcdBase),hl
	call _clrTxtShd
	call _homeUp
	call _drawStatusBar
	set graphDraw, (iy+graphFlags)
	ret

LOOP_noLevel:
	; draw main rectangle
	ld hl,pixelshadow
	ld (hl),8
	ld de,pixelshadow+1
	ld bc,80*250
	ldir

	ld hl,pixelshadow+(250*27)+60
	ld ix,TXT_Empty
	call putGDFont

	ld de,pixelshadow
	ld hl,vRam+(80*320)+35
	ld b,80
NOL_ANIM_dispRectInfoY:
	push bc
	ld b,250
NOL_ANIM_dispRectInfoX:
	ld a,(de)
	ld (hl),a
	ld a,10
NOL_DSP_pause:
	ld ix,(0)
	dec a
	jr nz,NOL_DSP_pause
	inc hl
	inc de
	djnz NOL_ANIM_dispRectInfoX
	ld bc,320-250
	add hl,bc
	pop bc
	djnz NOL_ANIM_dispRectInfoY

	call DEBUG
	jr quit
TXT_Empty:
	.db 5,5,13,16,20,25

findHighScoreInAppVar:
	; INPUT :
	;	DE = ID of level
	; OUTPUT :
	;	NZ : High score not found
	;	IX : addr of high-score (if flag Z set)
	push de
	ld hl,AppvarStoreScore
	call _mov9ToOp1
	call _chkFindSym
	call _chkInRam
	jr z,stoScoreInRAM
	ld hl,18
	add hl,de
	ex de,hl
stoScoreInRAM:
	ex de,hl
	ld de,(hl)
	call _setDEUto0
	; dividing by 6
	push hl
	ex de,hl
	ld bc,-1
	ld de,-6
	inc bc
	add hl,de
	jr c,$-2
	pop ix

	inc ix
	inc ix
	pop de
loop_findHighScoreInAppVar:
	ld hl,(ix)
	inc ix
	inc ix
	inc ix
	inc ix
	inc ix
	inc ix
	or a
	sbc hl,de
	jr z,foundHighScore
	dec c
	jr nz,loop_findHighScoreInAppVar
	dec b
	jr nc,loop_findHighScoreInAppVar
	or 1 ; flag Z reset
	ret
foundHighScore:
	dec ix
	dec ix
	dec ix
	ret


currentDrawLoc:
	.dl vram+(lcdWidth*lcdHeight)
AppvarStoreScore:
	.db appVarObj,"GeomDash"
AppVarGraphics:
	.db appvarObj,"GDGrphc",0
AppVarMenu:
	.db appvarObj,"GDMenu",0
stringToFind:
	.db 12,$FF,"Epharius",$FF,"GD"
current_level:
	.dl 0

ERR_needGrphc:
	.db "Need Appvar GDGrphc",0
ERR_needMenu:
	.db "Need Appvar GDMenu",0

;	MEMO: À faire à chaque conversion :
;		- copier couleurs JUMP à la fin de la palette
;		- enlever pixels parasites sur pics
;		- MILIEU :
;			dw 0FFFFh
;			dw 06A32h
;			dw 07BE9h
;			dw 0FFEDh
;			dw 12288
;			dw 0D002h
;		- FIN :
;			dw 0FFFFh
;			dw 06A32h
;			dw 07BE9h
;			dw 0F2C8h
;			dw 0D002h
;		- remplacer les particules par des pixels transparents aux trampolines
;		- Lancer le compresseur

#include "graphicFuncs.z80"
#include "game.z80"
#include "endlevel.z80"
#include "data.z80"

.echo "Size : ", $ - start
.end